<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 构造函数模式 ： 解决了私有属性的问题；
   /* function Fn(m,n) {
        var  a =10;
        // 在构造函数，通过this给实例新增的属性都是私有属性；
        this.x = m;
        this.y = n;
        // 输出当前实例x对应的属性值；
       /!* this.getX = function () {
            console.log(this.x);
        }*!/
    }
    // 把getX 这个属性统一放到当前实例所属类的prototype这个属性上；getX 就是Fn产生实例的一个公有属性；
    Fn.prototype.getX = function () {
        console.log(this.x);
    };
    var f = new Fn(100,200);
    console.log(f);// {x:100,y:200}
    f.getX();// 100
    var  f1 = new Fn(300,400);// f1 {x:300,y:400}
    f1.getX();// 300
    // f和f1 都是调用了Fn.prototype这个属性中getX的空间地址；
    console.log(f.getX === f1.getX);
    //console.log(f.getX === f1.getX);// false; f中的getX和f1的getX不是同一个空间地址；代表是不同的堆内存；
    console.log("toString" in f);*/// toString 是f的一个公有的属性；
    //Fn :{prototype:{constructor:Fn}}
    // 原型模式： 解决了实例公有属性的问题；

    // 原型模式：
    // 1. 每一个函数都天生自带一个prototype属性，这个prototype属性的属性值是一个对象；
    // 2. 这个属性值的对象中自带一个constructor属性，这个属性的属性值是当前原型所属的那个类
    // 3. 每一个对象数据类型都天生自带一个__proto__属性，它的属性值指向当前实例所属类的原型；

    // 实例一定是一个对象；

    function Fn() {
        this.x = 100;
        this.y = 200;
    }
    Fn.prototype.getX = function () {
        console.log(this.x);
    }
    var f = new Fn;
    console.log(Fn.prototype);
    console.log(f.getX);
    console.log(f.getX === f.__proto__.getX);
    console.log(Fn.prototype.getX === f.__proto__.getX);
    console.log(f.constructor === Fn.prototype.constructor);
    console.log(f.constructor);// 省略了__proto__这个属性；但是prototype不可以省略；
    console.log(Fn.constructor);// Function;

</script>
</body>
</html>