<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // es6   同步和异步；
    // 1. let  const
    // 2. 解构赋值
    // 3. set的数据结构： 数组的去重；
    // 4. Array.from   Array.of
    // 5. 函数的扩展   1.参数的默认值  2. 参数的解构赋值
    // 6. 箭头函数
    // 7. Generator
    // 8. class

    function fn(x=1,y=2) {
    }
    fn(3,undefined)

    function f([x,y]) {

    }
    f([3,4])

    //

    // 箭头函数
    let fn =()=>{};
    let fn =num=>{};
    let fn =num =>console.log(num);
    let fn =num=>num;
    // 执行上：
    // 1. 没有this；this会指向当前箭头函数定义时所在作用域下的this指向；
    // 2. 没有arguments；剩余运算符
    // 3. 不能作为构造函数；不能被new；
    // 4. 不能使用yield命令；

    var total =100;
    function fn() {
        var total =10;
        return function () {
            console.log(total)
        }
    }
    var  f = fn();
    f();


    // class  定义类 : 继承私有和公有；
     class A extends B{
         constructor(){
             super();
             this.z=10;
         }
         getY(){

         }
     }

     // 同步异步
    // JS：单线程   浏览器： 多线程；
    // 同步的是主任务队列；异步的是等待任务队列
    // 在JS加载时，会把所有的主任务队列的代码执行完毕，才会执行等待任务队列中代码；
    // 异步： 定时器、ajax、事件、回调函数、promise、async...


    // 事件循环：
    //1.所有的代码都要通过函数调用栈中调用执行。
    //2.当遇到前文中提到的APIs的时候，会交给浏览器内核的其他模块进行处理。
    //3.任务队列中存放的是回调函数。
    //4.等到调用栈中的task执行完之后再回去执行任务队列之中的task。


</script>
</body>
</html>